/* This block of code will go into the header file generated by bison */
%code requires{
  class Data;
}

/* This block will be put into the cpp source code */
%{
 #include <cstdio>
 #include <cstdlib>
 #include "lexer.hpp"

 void yyerror( const char * msg );

class Data {
  public:
    int data;
    Data() : data( 0 ) {}
    ~Data() {}
};

%}

%union {
  double dval;
  int ival;
  Data* cval;
}

%define parse.error verbose
%locations

%start input
%token MULT DIV PLUS MINUS EQUAL L_PAREN R_PAREN END
%token <dval> NUMBER
%type <dval> exp
%type <cval> input
%left PLUS MINUS
%left MULT DIV
%nonassoc UMINUS


%%
input:
               { $$ = new Data();     }
  | input line { $$ = $1; $1->data++; }
  ;

line:
    exp EQUAL END { printf( "\t%f\n", $1 ); }
  | END           { exit( EXIT_SUCCESS ); }
  ;

exp:
    NUMBER        { $$ = $1;      }
  | exp PLUS exp  { $$ = $1 + $3; }
  | exp MINUS exp { $$ = $1 - $3; }
  | exp MULT exp  { $$ = $1 * $3; }
  | exp DIV exp   {
      if ( $3 == 0 ) { yyerror( "divide by zero" ); } else { $$ = $1 / $3; }
    }
  | MINUS exp %prec UMINUS { $$ = -$2; }
  | L_PAREN exp R_PAREN    { $$ = $2;  }
  ;
%%

  int
main( int argc, char * argv[] )
{
  if ( 1 < argc )
    {
      yyin = fopen( argv[1], "r" );
      if ( yyin == NULL )
        {
          printf( "syntax: %s filename\n", argv[0] );
        }
     }
   yyparse();  /* Calls yylex() for tokens. */
   return EXIT_SUCCESS;
}

  void
yyerror( const char * msg )
{
   printf( "** Line %d: %s\n", yylloc.first_line, msg );
}
